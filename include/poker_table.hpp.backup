#ifndef POKER_TABLE_HPP
#define POKER_TABLE_HPP

#include "interactable.hpp"
#include "deck.hpp"
#include "card.hpp"
#include "physics.hpp"
#include <ode/ode.h>
#include <array>
#include <vector>

#define MAX_SEATS 8    // 8 seats around the table (2 per side)
#define SMALL_BLIND 5
#define BIG_BLIND 10

// Collision categories (shared with player.hpp)
#ifndef COLLISION_CATEGORY_PLAYER
#define COLLISION_CATEGORY_PLAYER   (1 << 0)  // 0001
#define COLLISION_CATEGORY_ITEM     (1 << 1)  // 0010
#define COLLISION_CATEGORY_TABLE    (1 << 2)  // 0100
#endif

// Forward declarations
class Player;
class Person;
class Dealer;
class Chip;

struct Seat {
    Vector3 position;     // World position of the seat
    Person* occupant;     // Person sitting in this seat (nullptr if empty)
    bool isOccupied;      // Quick check for seat availability
    int chipCount;        // Total chip value this seat has (tracked separately from inventory)
    bool hasFolded;       // Whether this seat has folded this hand
    bool isAllIn;         // Whether this seat is all-in
    int currentBet;       // How much this seat has bet this street
};

struct HandEvaluation {
    int seatIndex;
    int handRank;  // 0=high card, 1=pair, 2=two pair, etc. (TODO: implement)
    int tiebreaker; // For comparing hands of same rank (TODO: implement)
};

class PokerTable : public Interactable {
private:
    std::array<Seat, MAX_SEATS> seats;
    Deck* deck;        // Owned by this table (as child)
    Dealer* dealer;    // Owned by this table (as child)
    
    Vector3 size;
    Color color;
    dGeomID geom;
    PhysicsWorld* physics;
    
    // Poker game state (using proper poker terminology)
    bool handInProgress;      // Is a hand currently being played
    int currentStreet;        // 0=preflop, 1=flop, 2=turn, 3=river (betting rounds are called "streets")
    int dealerButtonSeat;     // Index of seat with dealer button (rotates each hand)
    int smallBlindSeat;       // Index of seat posting small blind
    int bigBlindSeat;         // Index of seat posting big blind
    int pot;                  // Total chips in the pot
    std::vector<Card*> communityCards;  // Board cards (flop, turn, river) - owned as children
    
    // Betting state
    bool bettingInProgress;   // Is betting round active
    int currentBettorSeat;    // Seat index of player whose turn it is
    int streetBet;            // Current bet to call (highest bet this street)
    int lastRaiserSeat;       // Last seat that raised (betting ends when we get back to them)
    int lastAggressorSeat;    // Last seat to bet/raise (used to determine action start)
    
    // Hand tracking
    std::array<Card*, MAX_SEATS * 2> holeCards;  // 2 cards per seat (owned as children)
    
public:
    PokerTable(Vector3 pos, Vector3 tableSize, Color tableColor, PhysicsWorld* physicsWorld);
    virtual ~PokerTable();
    
    // Override virtual functions
    void Update(float deltaTime) override;
    void Draw(Camera3D camera) override;
    void Interact() override;
    const char* GetType() const override;
    
    // Seat management
    int FindClosestOpenSeat(Vector3 personPos);
    bool SeatPerson(Person* person, int seatIndex);
    void UnseatPerson(Person* person);
    int FindSeatIndex(Person* person);
    
    // Poker game methods (using proper terminology)
    void StartNewHand();                 // Start a new hand (deals hole cards, posts blinds)
    void EndHand();                      // End current hand, collect cards, award pot
    void AdvanceToNextStreet();          // Progress to next street (preflop->flop->turn->river)
    void DealHoleCards();                // Deal 2 hole cards to each seated player
    void DealFlop();                     // Deal the flop (first 3 community cards)
    void DealTurn();                     // Deal the turn (4th community card)
    void DealRiver();                    // Deal the river (5th community card)
    void DealCommunityCard();            // Generic method to deal one community card
    void RotateDealerButton();           // Move dealer button clockwise to next player
    void AssignBlinds();                 // Assign small and big blind positions based on button
    void CollectBlinds();                // Post blinds (take chips from SB and BB)
    void ClearBoardAndHoleCards();       // Clear all cards from table
    int GetNextActiveSeat(int currentSeat);  // Get next seat clockwise that hasn't folded
    int GetNextOccupiedSeat(int currentSeat);  // Get next occupied seat clockwise
    int GetActiveSeatCount();            // Count seats that haven't folded
    int GetOccupiedSeatCount();          // Count occupied seats
    
    // Chip management (uses inventory system)
    int RemoveChipsFromInventory(Person* person, int amount);  // Remove chips, return amount removed
    void AddChipsToInventory(Person* person, int amount);      // Add chips to inventory
    int CountChipsInInventory(Person* person);                 // Count total chip value
    
    // Betting methods
    void StartBettingRound();            // Start a betting round (preflop/flop/turn/river)
    void ProcessCurrentBet(float deltaTime);  // Process current player's bet
    bool IsBettingComplete();            // Check if betting round is done
    void ExecuteBettingAction(int seatIndex, int action, int raiseAmt);  // Execute fold/call/raise/check
    void ResetStreetBets();              // Reset bets for new street
    
    // Hand evaluation (simplified for now)
    int DetermineWinner();               // Returns seat index of winner (-1 if tie)
    void AwardPot(int winningSeat);      // Award pot to winner
    
    // Accessors
    Deck* GetDeck() { return deck; }
    Dealer* GetDealer() { return dealer; }
    dGeomID GetGeom() const { return geom; }
    int GetPot() const { return pot; }
    int GetCommunityCardCount() const { return communityCards.size(); }
    Seat* GetSeat(int index) { return (index >= 0 && index < MAX_SEATS) ? &seats[index] : nullptr; }
    int GetCurrentBettorSeat() const { return currentBettorSeat; }
    int GetStreetBet() const { return streetBet; }
    bool IsBettingActive() const { return bettingInProgress; }
};

#endif
